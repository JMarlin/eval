Eval:
-----

	Eval is a toy programming language built to see how simply an evaluation graph based functional language can be built. The core idea is that there should be a generic node type which can either be a function, a primitive operation, a variable or a literal. Functions will be then composed of a tree of other functions,

add 2 add 3 4 = add
	        / \
	       2  add
		  / \
		 3   4

we read the add token, find that its a two-sided operator and evaluate its left
	we read the left, which is the literal 2
	we read the right, find that it is a two-sided operator and evaluate its left
		we read the left, which is the literal 3
		we read the right, which is the literal 4
		we apply the operator between left[3] and right[4] and return 7
	we apply the operator between left[2] and right[7] and return 9
 
More generically:
function eval:
	token = readT()
	switch(matchT(token))
		case LITERAL:
			return litval(token)
		case LEFT_ONLY:
			return leftop(token)(eval())
		case LEFT_RIGHT:
	 	 	return leftrightop(token)(eval(), eval())

Eval cases:
	if it consists of only digits, it is a literal
	if it matches an operator entry, it is an operator
	otherwise, it is a symbol
	
New operator: set
	set is an lr operator which takes the name of a symbol in its left side and assigns it the value generated by evaluating the right side. e.g.:
	
	set x add 2 3
	
	causes x to contain 5. When an eval file is parsed, the parser generates a set of solution trees represented by the equations in eval. It then
	starts execution by evaluating symbol main. Prior to the start of main's evaluation, the code has been converted into trees but no evaluation has
	taken place. As main is evaluated, the evaluation of any symbols used in main are triggered as needed for calculation and never before. To speed future
	execution when a set is evaluated for the first time the evaluator attempts to do as much tree collapsing as possible. For example, operations or symbols
	which are IO bound cannot be collapsed while any purely computative operators with children which ultimately evaluate to literals can be ultimately reduced
	to a literal themselves so that they don't have to be collapsed in future evaluations.
	
	set main mult x add y 7
	set x = 5
	set y = div x add 1 1
	
	-----------------------------------------------
	
	 main          x          y
	  |            |          |
	 mult          5         div
	 / \                     / \
	x   add                 x   add
	    / \                     / \
	   y   7                   1   1
	
	-----------------------------------------------
	
	main                   main                 main                    main              main            main           main
	 |                      |                    |                       |                 |               |              |
	mult                   mult                 mult                    mult              mult            mult           45
    / \         ->         / \           ->     / \          ->         / \        ->     / \       ->    / \    ->
   5   add                5   add              5   add                 5   add           5   add         5   9
       / \                    / \                  / \                     / \               / \
	  y   7                div   7              div   7                 div   7             2   7 
	                       / \                  / \                     / \
						  x   add              5   add                 5   2 
						      / \                  / \
 							 1   1                1   1
	  
	if is an interesting operator. It takes a left and, if it evaluates to be nonzero, causes the right to be evaluated. Otherwise, the right is never evaluated
	and if returns some kind of bullshit (this really needs a way to do an else for this to work right)
	
	
	node struct:
		nodetype = symbol, operation, literal
		nodeval = if this is a literal node, the literal value of the node 
		nodename = if this is a symbol, the name of the symbol
		nodeop = if this is an operation, the type of operation it represents
		nodeleft = if this is an operation, this is a pointer to the node struct of the left argument
		noderight = if this is an operation, this is a pointer to the node struct of the right argument
		
		